package main

import (
	vm "almeng.com/glang-vm"
	"almeng.com/glang/core/compiler"
	"almeng.com/glang/core/ir"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
)

var (
	srctype uint8
	output  string
	dest    uint8
	path    string
	verbose *bool
	defers  = make([]func(), 0)
)

// BuildExec modes
const (
	// Src to IR
	Src uint8 = iota
	// IR to BC
	IR
	// BC to Executable
	BC

	Exec
)

func main() {
	defer ClearTmp()
	parseFlag()
	// TODO: support llvm version
	//c := compiler.Compile(path, *verbose, *target)
	//BuildExec(c)

	switch path[len(path)-3:] {
	case ".gg":
		srctype = Src
	case ".ir":
		srctype = IR
	case ".bc":
		srctype = BC
	}
	if srctype == dest {
		fmt.Println("Error: Source and destination type are the same")
		os.Exit(1)
	}

	if srctype > dest {
		fmt.Println("Error: Source type is higher than destination type")
		os.Exit(1)
	}
	if output != "" && len(output) > 3 {
		outtyp := Exec
		switch output[len(output)-3:] {
		case ".gg":
			outtyp = Src
		case ".ir":
			outtyp = IR
		case ".bc":
			outtyp = BC
		}
		if outtyp != dest {
			fmt.Println("Error: Output and destination type are not the same")
			os.Exit(1)
		}
	} else {
		switch dest {
		case IR:
			output = "out.ir"
		case BC:
			output = "out.bc"
		case Exec:
			output = "out"

		}
	}

	Compile(srctype)
}

func Compile(srctype uint8) {
	var bc []byte
	_ir := ""
	for dest > srctype {
		switch srctype {
		// Src to IR
		case Src:
			c := compiler.CompileSrc(path, *verbose)
			_ir = c.GetIR()
			if *verbose {
				fmt.Println("Generated IR:")
				fmt.Println(_ir)
			}
			srctype++
			continue
		// IR to BC
		case IR:
			if _ir == "" {
				_ir = string(ReadSource(path))
			}
			bc = ir.NewAssembler(_ir).GenBC()
			if *verbose {
				fmt.Println("Generated Bytecode:")
				for i, v := range bc {
					if i%16 == 0 {
						if i != 0 {
							fmt.Println()
						}
						fmt.Printf("%08x: ", i)
					}
					fmt.Printf("%02x ", v)

				}
				fmt.Println()
				fmt.Println("Size:", Bitsize(len(bc)))
			}
			bc = append(bc, vm.Uint16ToBytes(uint16(vm.EOF))...)
			srctype++
			continue
		// BC to Executable
		case BC:
			if bc == nil {
				bc = ReadSource(path)
			}
			srctype++
			continue
		}

	}
	switch dest {
	case IR, BC:
		wd, err := os.Getwd()
		if err != nil {
			panic(err.Error())
		}
		contemt := []byte(_ir)
		if dest == BC {
			contemt = bc
		}
		err = ioutil.WriteFile(wd+"/"+output, contemt, 0644)
		if err != nil {
			panic(err.Error())
		}
	case Exec:
		BuildExec(bc)
	}
	BuildExec(bc)
}

const module = `module main
	
	go 1.18
	
	replace almeng.com/glang/vm => /Users/seungyeoplee/Workspace/glang/vm
	
	require almeng.com/glang/vm v0.0.0`

const GoPrefix = `package main
	
import (
	"almeng.com/glang/vm"
)

func main() {
	vm.Execute(`

func GoCode(code []byte) string {
	bcsrc := "[]byte{\n"
	for i, v := range code {
		if i%16 == 0 {
			if i != 0 {
				bcsrc += "\n"
			}
			bcsrc += "\t"
		}
		bcsrc += fmt.Sprintf("%d,", v)
	}
	bcsrc += "\n\t}"
	return GoPrefix + bcsrc + ")\n}"
}

func BuildExec(code []byte) {
	wd, _ := os.Getwd()
	temp := wd + "/build"
	err := os.MkdirAll(temp, os.ModePerm)
	if err != nil {
		panic(err)
	}
	defer os.RemoveAll(temp)
	goCode := GoCode(code)

	// Write go.mod
	err = ioutil.WriteFile(temp+"/go.mod", []byte(module), 0644)
	if err != nil {
		panic(err)
	}
	// Write main.go
	err = ioutil.WriteFile(temp+"/main.go", []byte(goCode), 0644)
	if err != nil {
		panic(err)
	}
	// BuildExec go
	cmd := exec.Command("go", "build", "-o", wd+"/"+output, temp+"/main.go")
	cmd.Dir = temp
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()

	if err != nil {
		panic(err.Error())
	}
}

func ReadSource(path string) []byte {
	file, err := os.Open(path)
	if err != nil {
		panic(err.Error())
	}
	defers = append(defers, func() {
		ferr := file.Close()
		if ferr != nil {
			return
		}
	})
	src, err := io.ReadAll(file)
	if err != nil {
		panic(err.Error())
	}
	return src
}

func ClearTmp() {
	for _, f := range defers {
		f()
	}
}

func parseFlag() {
	verbose = new(bool)
	*verbose = false
	output = ""
	args := os.Args[1:]
	dest = Exec
	mod_args := make([]string, 0)
	for i, v := range args {
		if v != "" && v[0] == '-' {
			switch v {
			case "-v", "--verbose":
				*verbose = true
			case "-bc":
				if dest != Exec {
					fmt.Println("Warning: Ignoring -bc flag. Compile destination already set")
					continue
				}
				dest = BC
			case "-o":
				if len(args) > i+1 {
					output = args[i+1]
					args[i+1] = ""
				}

			case "-ir":
				if dest != Exec {
					fmt.Println("Warning: Ignoring -ir flag. Compile destination already set")
					continue
				}
				dest = IR
			}
		} else if v != "" {
			mod_args = append(mod_args, v)
		}
	}
	if len(mod_args) != 2 {
		fmt.Println("invalid args")
		os.Exit(1)
	}
	if mod_args[0] != "build" {
		panic("invalid arg")
	}
	path = mod_args[1]
}

const (
	Byte = iota
	KB
	MB
	GB
	TB
	PB
	EB
	ZB
	YB
)

var bsize = []string{"B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"}

func Bitsize(size int) string {
	b := 0
	for size > 1024 && b < YB {
		size = size >> 10
		b++
	}
	return fmt.Sprintf("%d%s", size, bsize[b])
}
