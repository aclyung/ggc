package main

import (
	vm "almeng.com/glang-vm"
	"almeng.com/glang/core/compiler"
	"almeng.com/glang/core/ir"
	"fmt"
	"github.com/inhies/go-bytesize"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"runtime"
	"strings"
)

var (
	srctype              uint8
	output               string
	dest                 uint8
	path                 string
	run                  *bool
	verbose              *bool
	targetOS, targetArch string
	defers               = make([]func(), 0)
)

// BuildExec modes
const (
	// Src to IR
	Src uint8 = iota
	// IR to BC
	IR
	// BC to Executable
	BC

	Exec
)

func main() {
	defer ClearTmp()
	parseFlag()
	// TODO: support llvm version
	//c := compiler.Compile(path, *verbose, *target)
	//BuildExec(c)
	//vm.NewVM(ReadSource("./foo.bc")).Execute()
	switch path[len(path)-3:] {
	case ".gg":
		srctype = Src
	case ".ir":
		srctype = IR
	case ".bc":
		srctype = BC
	}

	if *run && srctype == BC {
		vm.NewVM(ReadSource(path)).Execute()
		return
	}
	if srctype == dest {
		fmt.Println("Error: Source and destination type are the same")
		os.Exit(1)
	}

	if srctype > dest {
		fmt.Println("Error: Source type is higher than destination type")
		os.Exit(1)
	}
	outtyp := Exec
	if output != "" && len(output) > 3 {
		switch output[len(output)-3:] {
		case ".gg":
			outtyp = Src
		case ".ir":
			outtyp = IR
		case ".bc":
			outtyp = BC
		}
		if outtyp != dest {
			fmt.Println("Error: Output and destination type are not the same")
			os.Exit(1)
		}
	}

	if output == "" {
		switch dest {
		case Exec:
			output = "out"
		case IR:
			output = "out.ir"
		case BC:
			output = "out.bc"
		}
	}

	Compile(srctype)
}

func Compile(srctype uint8) {
	var bc []byte
	_ir := ""
	for dest > srctype {
		switch srctype {
		// Src to IR
		case Src:
			c := compiler.CompileSrc(path, *verbose)
			_ir = c.GetIR()
			if *verbose {
				fmt.Println("Generated IR:")
				fmt.Println(_ir)
			}
			srctype++
			continue
		// IR to BC
		case IR:
			if _ir == "" {
				_ir = string(ReadSource(path))
			}
			bc = ir.NewAssembler(_ir).GenBC()
			if *verbose {
				fmt.Println("Generated Bytecode:")
				for i, v := range bc {
					if i%16 == 0 {
						if i != 0 {
							fmt.Println()
						}
						fmt.Printf("%08x: ", i)
					}
					fmt.Printf("%02x ", v)

				}
				fmt.Println()
				fmt.Println("Size:", Bitsize(float64(len(bc))))
			}
			bc = append(bc, vm.Uint16ToBytes(uint16(vm.EOF))...)
			srctype++
			continue
		// BC to Executable
		case BC:
			if bc == nil {
				bc = ReadSource(path)
			}
			srctype++
			continue
		}

	}
	if *run {
		vm.NewVM(bc).Execute()
		return
	}
	switch dest {
	case IR, BC:
		wd, err := os.Getwd()
		if err != nil {
			panic(err.Error())
		}
		contemt := []byte(_ir)
		if dest == BC {
			contemt = bc
		}
		err = ioutil.WriteFile(wd+"/"+output, contemt, 0644)
		if err != nil {
			panic(err.Error())
		}
	case Exec:
		BuildExec(bc)
	}
}

const module = `module main
	
	go 1.18
	
	replace almeng.com/glang/vm => redirect
	
	require almeng.com/glang/vm v0.0.0`

func ModString(vmPath string) string {
	return strings.ReplaceAll(module, "redirect", vmPath)
}

const GoPrefix = `package main
	
import (
	"almeng.com/glang/vm"
)

func main() {
	vm.NewVM(`

func GoCode(code []byte) string {
	bcsrc := "[]byte{\n"
	for i, v := range code {
		if i%16 == 0 {
			if i != 0 {
				bcsrc += "\n"
			}
			bcsrc += "\t"
		}
		bcsrc += fmt.Sprintf("%d,", v)
	}
	bcsrc += "\n\t}"
	return GoPrefix + bcsrc + ").Execute()\n}"
}

func BuildExec(code []byte) {
	wd, _ := os.Getwd()
	temp := wd + "/build"
	err := os.MkdirAll(temp, os.ModePerm)
	if err != nil {
		panic(err)
	}
	defer os.RemoveAll(temp)
	goCode := GoCode(code)
	executable, err := os.Executable()
	if err != nil {
		return
	}

	vm_lib := executable[:strings.LastIndex(executable, string(os.PathSeparator))+1] + "vm"
	// Write go.mod
	mod := ModString(vm_lib)
	err = ioutil.WriteFile(temp+"/go.mod", []byte(mod), 0644)
	if err != nil {
		panic(err)
	}
	// Write main.go
	err = ioutil.WriteFile(temp+"/main.go", []byte(goCode), 0644)
	if err != nil {
		panic(err)
	}
	// BuildExec go
	cmd := exec.Command("go", "build", "-o", wd+"/"+output, temp+"/main.go")
	cmd.Dir = temp
	cmd.Env = os.Environ()
	osSet, archSet := false, false
	for i, v := range cmd.Env {
		if strings.HasPrefix(v, "GOOS=") {
			cmd.Env[i] = "GOOS=" + targetOS
			osSet = true
		}
		if strings.HasPrefix(v, "GOARCH=") {
			cmd.Env[i] = "GOARCH=" + targetArch
			archSet = true
		}
	}
	if !osSet {
		cmd.Env = append(cmd.Env, "GOOS="+targetOS)
	}
	if !archSet {
		cmd.Env = append(cmd.Env, "GOARCH="+targetArch)
	}
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()

	if err != nil {
		panic(err.Error())
	}
}

func ReadSource(path string) []byte {
	file, err := os.Open(path)
	if err != nil {
		panic(err.Error())
	}
	defers = append(defers, func() {
		ferr := file.Close()
		if ferr != nil {
			return
		}
	})
	src, err := io.ReadAll(file)
	if err != nil {
		panic(err.Error())
	}
	return src
}

func ClearTmp() {
	for _, f := range defers {
		f()
	}
}

func parseFlag() {
	verbose = new(bool)
	*verbose = false
	run = new(bool)
	*run = false
	output = ""
	args := os.Args[1:]
	dest = Exec
	mod_args := make([]string, 0)
	targetOS = runtime.GOOS
	targetArch = runtime.GOARCH
	for i, v := range args {
		if v != "" && v[0] == '-' {
			switch v {
			case "-t", "--target":
				if len(args) > i+1 {
					targetOS = args[i+1]
					args[i+1] = ""
				}
			case "-a", "--arch":
				if len(args) > i+1 {
					targetArch = args[i+1]
					args[i+1] = ""
				}
			case "-v", "--verbose":
				*verbose = true
			case "-bc":
				if dest != Exec {
					fmt.Println("Warning: Ignoring -bc flag. Compile destination already set")
					continue
				}
				dest = BC
			case "-o":
				if len(args) > i+1 {
					output = args[i+1]
					args[i+1] = ""
				}

			case "-ir":
				if dest != Exec {
					fmt.Println("Warning: Ignoring -ir flag. Compile destination already set")
					continue
				}
				dest = IR
			}
		} else if v != "" {
			mod_args = append(mod_args, v)
		}
	}
	if len(mod_args) != 2 {
		fmt.Println("invalid args")
		os.Exit(1)
	}

	if mod_args[0] == "run" {
		path = mod_args[1]
		*run = true
		if dest != Exec {
			fmt.Println("Warning: Ignoring -bc/-ir flag. Command was already set to run")
		}
		dest = BC
		if output != "" {
			fmt.Println("Warning: Ignoring -o flag. Command was already set to run(no build output)")
		}
		output = "_.bc"
		return
	}

	if mod_args[0] != "build" {
		panic("invalid arg")
	}
	path = mod_args[1]
	triple := targetArch + "-" + "dynamic" + "-" + targetOS
	if *verbose {
		defers = append(defers, func() { fmt.Println("Target:", triple) })
	}
	// Check validity of target specifier
	compiler.TargetFromTriple(triple)
}

const (
	Byte = iota
	KB
	MB
	GB
	TB
	PB
	EB
	ZB
	YB
)

var bsize = []string{"B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"}

func Bitsize(size float64) string {
	return bytesize.New(size).String()
}
